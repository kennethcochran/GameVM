# Internal Assembly API for Compiler Development

## Overview
This document outlines the design of an internal API that mimics assembly language instructions using standard C# functions. This API is intended to facilitate the writing of compilers for GameVM by allowing the compiler to generate machine code at compile time.

## Purpose
The API will be used to append corresponding machine instructions to a byte array during the compilation process. Once the compilation is complete, the byte array will be written to disk, including both the interpreter for the game code and the game code itself.

## API Design
The API will provide functions that correspond to assembly instructions for each target architecture. Each function will encapsulate the behavior of the corresponding assembly instruction, allowing for easy use in the compiler.

### Function Naming
- Functions will be named to reflect the assembly instructions they mimic (e.g., `LDA`, `STA`, `JMP`).

### Architecture-Specific APIs

Each target architecture will have its own assembly-like API, allowing for tailored functions that correspond to the specific assembly instructions of that architecture. This design facilitates optimizations and features unique to each architecture.

### Example Structure
- **6502 Architecture API**
  ```csharp
  public static class AssemblyAPI6502
  {
      public static void LDA(byte value) 
      {
          // Append LDA instruction for 6502 to byte array
      }

      public static void STA(byte address) 
      {
          // Append STA instruction for 6502 to byte array
      }
  }
  ```

- **Z80 Architecture API**
  ```csharp
  public static class AssemblyAPIZ80
  {
      public static void LD_A(byte value) 
      {
          // Append LD A instruction for Z80 to byte array
      }

      public static void LD_B(byte value) 
      {
          // Append LD B instruction for Z80 to byte array
      }
  }
  ```

### Benefits of Architecture-Specific APIs
- **Optimizations:** Each API can implement optimizations specific to the architecture's instruction set.
- **Feature Utilization:** Allows the compiler to take advantage of unique features of each architecture, such as special addressing modes or hardware capabilities.
- **Clarity and Maintainability:** Clear separation of functionality for each architecture makes the codebase easier to understand and maintain.

### Compile-Time Activity
- Unlike runtime activities, this API will be used during the compilation phase to generate the final machine code.
- The generated byte array will be stored in the ROM image along with the game code.

## Benefits
- Facilitates the creation of interpreters and code generators by providing a clear mapping between high-level constructs and machine instructions.
- Enhances modularity and maintainability of the compiler code.

## Conclusion
This internal API will play a crucial role in the development of the GameVM compiler, enabling efficient generation of machine code and supporting the overall architecture of the virtual machine.
